**왜 웹 프론트엔드에서는 정해진 대표적인 MVVM, MVC 와 같은 이러한 아키텍쳐가 없나요?**

웹에서 프론트엔드 백엔드 경계가 없던 2000년대 시절에는 이미 웹에서 HTML+CSS+JS 영역을 View라고 부르고 데이터를 Model, 라우터 서버스크립트 영역을 Controller라 부르면서 MVC 패턴이나 아키텍쳐는 이미 존재했습니다. 

이후 jQuery시절이 끝나고 웹 프론트엔드가 생겨날 무렵 backbone이나 ember와 같은 기존의 MVC 개념을 바탕으로 하는 프레임워크들도 나왔으나, knockoutjs, angularjs와 같이 HTML에서 템플릿과 치환자 그리고 데이터 바인딩과 자동 업데이트라는 방식이 기존의 MVC 개념보다 훨씬 더 효율적이고 쉽게 화면과 모델을 만들 수 있다는 것을 알게 되면서 이러한 방식이 대세가 되어 웹은 MVC를 건너뛰고 MVVM 아키텍쳐가 주류가 되었고 이 기조는 지금까지 이어집니다.

이후 FLUX 패턴이나 현재에 이르는 상태관리처럼 웹이 훨씬 더 이러한 아키텍쳐에 대해서 선구자적인 역할을 했고 이것들이 MVVM이나 MVI처럼 이름이 붙여지고 정리되는 것들은 나중의 일입니다. 당시에는 이러한 방식을 두고 MVC 옹호론자들이 이게 MVC에 맞느냐 뷰와 컨트롤러가 너무 강결합이 되어 있다 라던가 반대파들이 아니다 이건 MVP(Presenter)로 불러야 한다던가 등의 논쟁이 있었는데, angularjs의 경우는 하면서 MVW (Whatever)이라 부르면서 굳이 이런방식에 이름을 붙이고 정하려 하지말고 모델과 뷰 사이에서 가장 효율적인 패턴을 적용한다는 의미로 불러달라고 했습니다. 이게 2010년도 입니다.

이렇게 선언형 뷰를 만드는 방식은 이후 안드로이드나 ios Swift등에서 나중에 도입되면서 이게 MVVM 아키텍쳐가 되었고 이후에 나온 스토어를 따로 두고 행동에 의해 데이터가 변경되고 이를 반영하는 방식의 FLUX 패턴들이 MVI 등으로 정리가 되면서 이러한 아키텍쳐들이 벤더에 나중에 정리가 되며 적용이 되고 있는데 반해 웹은 계속 발전 중입니다. 

2020년도에 MVVM을 웹에서 해보려고 시도한것이라기 보다는 이미 웹 프론트에서 하고 있던 방식이 ios, android에서 가서 MVVM 아키텍쳐로 정립이 되면서 swift UI등의 개념들이 소개가 되면서 웹과 같이 엮었던거며 이미 웹은 오래전부터 MVVM 형태의 아키텍쳐가 주류였습니다.

웹 프로트엔드가 과도기라고 하면 과도기가 맞지만 (20년째 과도기...) 어떻게 보면 벤더가 없기에 계속 선구자의 역할을 하고 있고 그러다 보니 매년 새로운게 나오고 뭔가 정리가 되려고 하면 새로운 개념들이 또 나오고 있다보니 아키텍쳐로 정리가 되기 보다는 하나의 라이브러리와 넘쳐나는 새로운 개념과 아젠다들로 뒤덮여 있다보니 뭔가 웹 프론트엔드를 보기에는 이렇다 할 만한것으로 하나의 좋은 형태가 정해지지 못한것처럼 느껴진다고 볼 수 있을 것 같아요.



**DI와 같은 방식을 코드로 보고 싶어요.**

일단 웹 프론트엔드에서 쓰는 자바스크립트가 완전 함수형 프로그래밍 언어도 아니고 객체 지향 기반의 언어도 아니면서 프로토타입 객체지향을 기반으로 언어이지만 class는 잘 사용하지 않으려고 하는 경향이 있다는 것에 대해서 이해를 한다고 했기에 전제로 적어보려고 합니다. 

특히 React가 클래스 기반에서 완전히 함수형 기반으로 넘어가면서 주류 된 만큼 점점 더 class보다는 function을 쓰는 형태로 발전해가고 있다고 생각합니다. 
웹은 과도기가 맞는데 다시 class 전성기가 돌아올수도 있겠지만 지금까지는 오히려 class 과도기가 지나가고 function을 쓰는 방향으로 안정화가 되어가고 있다고 느껴집니다. 

위와 같은 이유로 일단 class를 잘 쓰지 않으니 굳이 DI(Dependecy Injection)이라는 것이 FE에서는 자주 쓰이지 않는 개념인 것이지지,
유연함을 위해서 모듈을 분리하고 상황에 맞게 모듈을 끼워넣을 수 있도록 하는 방법들은 함수형 프로그래밍에서 얼마든지 있다고 생각하빈다.

완전 돌아가는 형식의 코드가 아니라 일부만 적어보겠지만 이해는 해주실거라 생각합니다.


1
가령 클래스에서 이렇게 분리된 코드를 DI를 통해서 결합하면서 사용한다고 한다면,

public class MyApp {
  private readonly RepositoryLayer _repository;


  public MyApp(RepositoryLayer repository) {
    _repository = repository
    _repository.fetch(....)
  }
}

리액트에서 Context API를 이용한 Provider에서 Service 바꾸기
(이것이 일종의 DI라고 볼 수 있다고 생각합니다.)

import {repositoryService} 

<Service.Provider value={repositoryService}>
  <MyApp>
</Service.Provider>

const MyApp = () => {
  const repositoryService = useContext(Service);
  repositoryService.fetch(...)
}


2
이러한 방식이 React에거나 아니라 비지니스 로직을 짜는데 있어서 class를 활용하고 있지 않기 때문에 이건 DI라고 보기 힘들다라고 하셨는데...

const fetch_items = (service, params) => {
  return service.fetch(params)
}

이런식으로 작성을 해서 인자로 받아와도 동적으로 처리를 한다거나

import {MyService } from "..."
const service = MyService // 조건부나 빌드환경에 따라서 다른 서비스로 교체할수도 있음.

const fetch_items = (params) {
  return service.fetch(params)
}

와 같이 만들어도 DI와 같은 목적을 충분히 달성할 수 있고 아니면.


create MyRepositoryServce = (serviceLayer) => {

  const fetch_items = (params) {
    return service.fetch(params)
  }


  return {fetch_items)
}

const m1 = MyRepositoryServce(serviceForProd)
const m2 = MyRepositoryServce(serviceForTest)


이런식으로도 사용할 수 있을 거라고 생각합니다.


프론트엔드가 클래스를 사용하지 않아도 되는 상황이면 클래스보다는 함수를 사용하는 식으로 사고의 체계가 잡혀있게 되었는데 정확하게 어떤 목적과 의도에 맞는 코드를 원하는지는 정확하게 캐치못했을수도 있다고 생각을 합니다. 어떠한 의도와 목적인지를 안다면 그리고 그러한 취지에 맞는 코드를 구현하는데 있어서 더 나은 방식이 있는 거라면 억지로 우기는게 아니라 진짜 같이 고민을 해보고 싶습니다. 

이 주제가 어그로가 끌리는 이유는 그럴 의도와 무관하게 논조가 다분히 '왜 백엔드에는 전통적인 객체지향 방식에서는 이러한 좋은 것들이 있는데 왜 프론트엔드에서는 이런것들을 안 사용하려고 하는 건지 이해가 안된다' 라는 식으로 전개가 되고 있는데 그 부분이 뭔지 얘기가 안되다보니까 각자 자기 입장에서의 얘기를 할 수 밖에 없는 것 같아요. 

FE 입장을 대변하고 함수형이 객체지향보다 낫다라고 말하고 싶은 것은 절대 아니며 자바스크립트는 특히 객체지향과 함수형의 밸런스가 중요하다고 생각하기에 프론트엔드 일변도가 아닌 다른 관점에서 좋은 방향성 특히 테스트와 아키텍쳐에 관해서는 FE에서도 늘 답을 찾고 싶어 하는 주제이기에 이러한 얘기들이 자주 논의되면서 괜찮은 방법들을 찾고 새로운 시각을 갖추고 싶습니다. (이렇게 말을 하지만 저도 제 입장과 관점으로만 말할 거라고 생가합니다. 배우고 해온게 있으니까요... ㅎㅎ)