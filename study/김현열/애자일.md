**애자일**

소프트웨어 개발방법론의 하나로서 개발과 함께 즉시 피드백을 받아서 유동적으로 개발하는 방법

[은행, 게임산업의 발전과 더불어 빠른 비즈니스 시장에 대응할 수 있는 방법론]



**등장 배경**

기존 폭포수 개발방법론의 한계를 극복하기 위해 등장

소프트웨어 개발 트렌드가 모바일 환경으로 변화

시장 적시성과 잦은 배포의 중요성 부각

문서 및 절차위주로 변화에 신속한 대응이 어려움

빠르게 적용하고 효율적으로 개발할 수 있는 방법론이 필요했음



**특징**

기능중심으로 요구사항을 정의

절차와 도구보다 개인과 소통을 중요하게 여김

계획을 짧게 세워 요구 변화에 유연하고 신속하게  대응

잘 실행되는 데 가치를 둔다

고객과의 피드백을 중요시 함



**애자일 방법론**

xp, 린(lean), 스크럼(scrum)

xp - 의사소통 개선과 즉각적 피드백, 실용성을 강조한 방법론, 1~3주의 개발주기

5가지 가치, 12가지 원리

용기, 단순성, 의사소통, 피드백, 존중

짝 프로그래밍, 공동 코드 소유, 지속적인 통합(CI), 계획 세우기, 작은 릴리즈, 메타포어, 간단한 디자인, 테스트 기반 개발(TDD), 리팩토링, 40시간 작업, 고객 상주, 코드 표준



스크럼 - 매일 정해진 시간, 장소에서 짧은 시간의 개발을 하는 방법론 (프로젝트 관리 방법론)

백로그 - 제품과 프로젝트에 대한 요구사항

스프린트 - 2~4주의 짧은 개발기간으로 반복적 수행으로 개발품질 향상

스크럼 미팅 - 15분/1일 미팅 To-Do list 계획 수립

스크럼 마스터 - 프로젝트 리더 / 스크럼 수행 시 문제를 인지 및 해결하는 사람

스프린트 회고 - 스프린트 주기를 되돌아보며 정해놓은 규칙 준수 여부, 개선점 등을 확인 및 기록

​							해당 스프린트가 끝난 시점이나 일정 주기로 시행

번 다운 차트 - 남아있는 백로그 대비 시간을 그래픽적으로 표현한 차트

​						백로그는 보통 수직축에 위치하며 시간은 수평축에 위치



**린** - 도요타의 린 시스템 품질기법을 소프트웨어 개발 프로세스에 적용해서 낭비 요소를 제거하여 품질을 향상 시키는 방법론

[JIT, 칸반보드]

낭비제거 - 불필요한 코드나 기능과 같이 상품 가치에 영향을 미치지 않는 모든 것을 제거

품질 내재화 - TDD를 통해 코드의 실수를 방지

지식 창출 - 개발 과정에서 참여자 학습의 필요성 존재

늦은 확정 - 중요한 문제에 대한 의사 결정을 최대한 미루고 요구사항 변경에 대응

빠른 인도 - 결과물을 최대한 빠르게 제공 / 사용자의 불확실성 감소, 개발자는 결함발견의 기회

사람 존중 - 책임 의식

전체 최적화 - 요구사항 수집부터 배포까지 프로세스 최적화



| 비교대상  |            애자일             |                      전통적                      |
| :-------: | :---------------------------: | :----------------------------------------------: |
| 계획 수립 |            유동적             |                      확정적                      |
| 업무 수행 |         팀 중심 업무          | 관리자 주도적 명령<br />통제 및 개인 단위로 업무 |
| 개발/검증 | 반복 주기 단위로 개발 및 검증 |    분석 / 설계 / 구현 / 테스트를 순차적 진행     |
|  팀관리   |      업무 몰입, 팀 평가       |                 경쟁, 개별 평가                  |
|  문서화   |       문서화보다는 코드       |                  상세한 문서화                   |
| 성공요소  |        고객 가치 전달         |                 계획/ 일정 준수                  |
|   유형    |         xp 스크럼 린          |             폭포수 프로토타입 나선형             |



**지라** - 애플리케이션 생명주기 관리와 요구사항 관리에 사용하는 도구

비즈니스 요구사항과 기존 문제의 상관관계를 쉽게 파악 가능

※ 생명주기 - 요구사항 분석 => 설계 => 구현 => 테스트 => 유지보수 까지 전 공정을 쳬계화한 절차

소프트웨어 생명 주기 (SDLC) - sw development life cycle





프론트엔드에서 OOP를 왜 하지 않는가라고 한다면 아무래도 JS가 OOP보다는 함수형프로그래밍을 하기에 좋게 만들어진 것도 있고 TS나 class등의 언어가 나중에 만들어진 개념이다 보니 관성적으로 작용한것도 있다고 생각합니다. 무엇보다 JS에서 class를 하다보면 this의 존재가 거슬리고 함수형에 비해서 복잡해지니까요. React의 경우에도 class형일 경우에는 그렇게 인기가 없었습니다. 나중에 hook이 등장하고 functional이 본격화 되면서 주목을 받기 시작했구요. 잠깐 언급이 되었던 클래스로 만들게 될 경우 번들링의 크기를 줄일 수 없고 트리세이킹에도 약점이 있다보니 함수형으로 더더욱 진화를 하고 있다고 생각합니다. 말씀하신 문제는 FE개발을 하는데 있어서 FP로도 OOP로도 뭔가 정석(?)스러운게 아직 없다보니 이게 맞나? 하는 식의 과도기는 아직도 FE진영에 존재한다고 생각합니다. 하지만 훨씬 더 class스럽고 OOP한 방식으로 잘 만들어져있는 앵귤러가 FE진영에서 선택을 받지 못한 것을 보면 JS에서 class를 deep하게 다루는것이 그렇게 쉬운 작업은 아니라고 생각합니다. 화면을 다루기 위해서 익혀할 것이 너무 많아지게 되는 것 같아요. 리액트와 뷰에 대해서 왜 리액트를 더 많이쓰는가에 대해서는 앵귤러와 리액트 뷰 3대장인 시절에서 앵귤러는 그 복잡함과 비대함 그리고 OOP방식으로 만드는 방식에 대해 거부감을 느끼면서 리액트 뷰 양강체계가 되다가 결정적으로 Vue3를 만들겠다고 언급하고난 이후 Vue3가 너무 늦게 시장에 나와버렸습니다. 이미 Vue3를 선언한 이상 사람들이 생태계 발전이 조금씩 눈치를 보면서 천천히 하게되는데 리액트는 계속 발전을 하는데 뷰가 상대대적으로 머무르다보니 서서히 React 위주로 생태계가 재편이 되어버렸습니다. JSX방식이 다른 프레임워크에 비해 적는 문법을 가지다보니 유용함은 뒤로하더라도 IDE지원부터, Typescript, babel, 스토리북, Next, Remix, Framer 등 각종 생태계들이 React를 먼저 지원하게 되면서 React 1강 체계가 만들어저버렸습니다. 이후 Vue3가 나왔으나 Vue2에서 마이그레이션도 쉽지 않았고 이제 와서 Vue를? 하는 식으로 하다보니 많이쓰니까 많이 쓰게 되는 React가 되었다고 생각합니다. 저도 React가 정말 좋은가에 대해서는 의문이 있지만 백엔드에서 Java개발자를 구하기 쉽기에 Java를 쓰게 되는 것 처럼 React 생태계와 개발자 구인이 쉽다보니 React가 더 커지게 되는 것 같아요. 그리고 FE테스트는 OOP로 작성을 한다고 더 쉬워지거나 하지는 않는 것 같습니다. 그냥 FE는 테스트가 어려워요. mocking을 해야하는 이유는 대부분의 작업 의존성이 백엔드에 있는데 테스트를 주로 하는 부분이 백엔드 API에 있다보니 mocking이 발전을 했습니다. mocking을 하지 않고서 주요 로직을 테스트하지 않을 수 없으니까요. 백엔드에서 OOP를 하면서 테스트를 더 쉽게 할 수 있는 방법에 대해서 어떻게 하셨는지는 정말로 너무 궁금합니다. +_+ FE 테스트에 인사이트를 얻고 싶네요! 

